; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -S -mtriple=amdgcn--amdhsa -passes=load-store-vectorizer < %s | FileCheck %s
; RUN: opt -S -mtriple=amdgcn--amdhsa -passes='function(load-store-vectorizer)' < %s | FileCheck %s

; Check that vectorizer can find a GEP through bitcast
define void @vect_zext_bitcast_f32_to_i32_idx(ptr addrspace(1) %arg1, i32 %base) {
; CHECK-LABEL: define void @vect_zext_bitcast_f32_to_i32_idx(
; CHECK-SAME: ptr addrspace(1) [[ARG1:%.*]], i32 [[BASE:%.*]]) {
; CHECK-NEXT:    [[ADD1:%.*]] = add nuw i32 [[BASE]], 0
; CHECK-NEXT:    [[ZEXT1:%.*]] = zext i32 [[ADD1]] to i64
; CHECK-NEXT:    [[GEP1:%.*]] = getelementptr inbounds float, ptr addrspace(1) [[ARG1]], i64 [[ZEXT1]]
; CHECK-NEXT:    [[TMP1:%.*]] = load <4 x i32>, ptr addrspace(1) [[GEP1]], align 4
; CHECK-NEXT:    [[LOAD11:%.*]] = extractelement <4 x i32> [[TMP1]], i32 0
; CHECK-NEXT:    [[LOAD22:%.*]] = extractelement <4 x i32> [[TMP1]], i32 1
; CHECK-NEXT:    [[LOAD33:%.*]] = extractelement <4 x i32> [[TMP1]], i32 2
; CHECK-NEXT:    [[LOAD44:%.*]] = extractelement <4 x i32> [[TMP1]], i32 3
; CHECK-NEXT:    ret void
;
  %add1 = add nuw i32 %base, 0
  %zext1 = zext i32 %add1 to i64
  %gep1 = getelementptr inbounds float, ptr addrspace(1) %arg1, i64 %zext1
  %load1 = load i32, ptr addrspace(1) %gep1, align 4
  %add2 = add nuw i32 %base, 1
  %zext2 = zext i32 %add2 to i64
  %gep2 = getelementptr inbounds float, ptr addrspace(1) %arg1, i64 %zext2
  %load2 = load i32, ptr addrspace(1) %gep2, align 4
  %add3 = add nuw i32 %base, 2
  %zext3 = zext i32 %add3 to i64
  %gep3 = getelementptr inbounds float, ptr addrspace(1) %arg1, i64 %zext3
  %load3 = load i32, ptr addrspace(1) %gep3, align 4
  %add4 = add nuw i32 %base, 3
  %zext4 = zext i32 %add4 to i64
  %gep4 = getelementptr inbounds float, ptr addrspace(1) %arg1, i64 %zext4
  %load4 = load i32, ptr addrspace(1) %gep4, align 4
  ret void
}

define void @vect_zext_bitcast_i8_st1_to_i32_idx(ptr addrspace(1) %arg1, i32 %base) {
; CHECK-LABEL: define void @vect_zext_bitcast_i8_st1_to_i32_idx(
; CHECK-SAME: ptr addrspace(1) [[ARG1:%.*]], i32 [[BASE:%.*]]) {
; CHECK-NEXT:    [[ADD1:%.*]] = add nuw i32 [[BASE]], 0
; CHECK-NEXT:    [[ZEXT3:%.*]] = zext i32 [[ADD1]] to i64
; CHECK-NEXT:    [[GEP3:%.*]] = getelementptr inbounds i8, ptr addrspace(1) [[ARG1]], i64 [[ZEXT3]]
; CHECK-NEXT:    [[LOAD1:%.*]] = load i32, ptr addrspace(1) [[GEP3]], align 4
; CHECK-NEXT:    [[ADD2:%.*]] = add nuw i32 [[BASE]], 1
; CHECK-NEXT:    [[ZEXT2:%.*]] = zext i32 [[ADD2]] to i64
; CHECK-NEXT:    [[GEP2:%.*]] = getelementptr inbounds i8, ptr addrspace(1) [[ARG1]], i64 [[ZEXT2]]
; CHECK-NEXT:    [[LOAD2:%.*]] = load i32, ptr addrspace(1) [[GEP2]], align 4
; CHECK-NEXT:    [[ADD3:%.*]] = add nuw i32 [[BASE]], 2
; CHECK-NEXT:    [[ZEXT5:%.*]] = zext i32 [[ADD3]] to i64
; CHECK-NEXT:    [[GEP5:%.*]] = getelementptr inbounds i8, ptr addrspace(1) [[ARG1]], i64 [[ZEXT5]]
; CHECK-NEXT:    [[LOAD3:%.*]] = load i32, ptr addrspace(1) [[GEP5]], align 4
; CHECK-NEXT:    [[ADD4:%.*]] = add nuw i32 [[BASE]], 3
; CHECK-NEXT:    [[ZEXT4:%.*]] = zext i32 [[ADD4]] to i64
; CHECK-NEXT:    [[GEP4:%.*]] = getelementptr inbounds i8, ptr addrspace(1) [[ARG1]], i64 [[ZEXT4]]
; CHECK-NEXT:    [[LOAD4:%.*]] = load i32, ptr addrspace(1) [[GEP4]], align 4
; CHECK-NEXT:    ret void
;
  %add1 = add nuw i32 %base, 0
  %zext1 = zext i32 %add1 to i64
  %gep1 = getelementptr inbounds i8, ptr addrspace(1) %arg1, i64 %zext1
  %load1 = load i32, ptr addrspace(1) %gep1, align 4
  %add2 = add nuw i32 %base, 1
  %zext2 = zext i32 %add2 to i64
  %gep2 = getelementptr inbounds i8,ptr addrspace(1) %arg1, i64 %zext2
  %load2 = load i32, ptr addrspace(1) %gep2, align 4
  %add3 = add nuw i32 %base, 2
  %zext3 = zext i32 %add3 to i64
  %gep3 = getelementptr inbounds i8, ptr addrspace(1) %arg1, i64 %zext3
  %load3 = load i32, ptr addrspace(1) %gep3, align 4
  %add4 = add nuw i32 %base, 3
  %zext4 = zext i32 %add4 to i64
  %gep4 = getelementptr inbounds i8, ptr addrspace(1) %arg1, i64 %zext4
  %load4 = load i32, ptr addrspace(1) %gep4, align 4
  ret void
}

define void @vect_zext_bitcast_i8_st4_to_i32_idx(ptr addrspace(1) %arg1, i32 %base) {
; CHECK-LABEL: define void @vect_zext_bitcast_i8_st4_to_i32_idx(
; CHECK-SAME: ptr addrspace(1) [[ARG1:%.*]], i32 [[BASE:%.*]]) {
; CHECK-NEXT:    [[ADD1:%.*]] = add nuw i32 [[BASE]], 0
; CHECK-NEXT:    [[ZEXT1:%.*]] = zext i32 [[ADD1]] to i64
; CHECK-NEXT:    [[GEP1:%.*]] = getelementptr inbounds i8, ptr addrspace(1) [[ARG1]], i64 [[ZEXT1]]
; CHECK-NEXT:    [[TMP1:%.*]] = load <4 x i32>, ptr addrspace(1) [[GEP1]], align 4
; CHECK-NEXT:    [[LOAD11:%.*]] = extractelement <4 x i32> [[TMP1]], i32 0
; CHECK-NEXT:    [[LOAD22:%.*]] = extractelement <4 x i32> [[TMP1]], i32 1
; CHECK-NEXT:    [[LOAD33:%.*]] = extractelement <4 x i32> [[TMP1]], i32 2
; CHECK-NEXT:    [[LOAD44:%.*]] = extractelement <4 x i32> [[TMP1]], i32 3
; CHECK-NEXT:    ret void
;
  %add1 = add nuw i32 %base, 0
  %zext1 = zext i32 %add1 to i64
  %gep1 = getelementptr inbounds i8, ptr addrspace(1) %arg1, i64 %zext1
  %load1 = load i32, ptr addrspace(1) %gep1, align 4
  %add2 = add nuw i32 %base, 4
  %zext2 = zext i32 %add2 to i64
  %gep2 = getelementptr inbounds i8,ptr addrspace(1) %arg1, i64 %zext2
  %load2 = load i32, ptr addrspace(1) %gep2, align 4
  %add3 = add nuw i32 %base, 8
  %zext3 = zext i32 %add3 to i64
  %gep3 = getelementptr inbounds i8, ptr addrspace(1) %arg1, i64 %zext3
  %load3 = load i32, ptr addrspace(1) %gep3, align 4
  %add4 = add nuw i32 %base, 12
  %zext4 = zext i32 %add4 to i64
  %gep4 = getelementptr inbounds i8, ptr addrspace(1) %arg1, i64 %zext4
  %load4 = load i32, ptr addrspace(1) %gep4, align 4
  ret void
}

define void @vect_zext_bitcast_negative_ptr_delta(ptr addrspace(1) %p, i32 %base) {
; CHECK-LABEL: define void @vect_zext_bitcast_negative_ptr_delta(
; CHECK-SAME: ptr addrspace(1) [[P:%.*]], i32 [[BASE:%.*]]) {
; CHECK-NEXT:    [[A_OFFSET:%.*]] = add nuw i32 [[BASE]], 4
; CHECK-NEXT:    [[A_OFFSET_ZEXTED:%.*]] = zext i32 [[A_OFFSET]] to i64
; CHECK-NEXT:    [[A_PTR:%.*]] = getelementptr inbounds i16, ptr addrspace(1) [[P]], i64 [[A_OFFSET_ZEXTED]]
; CHECK-NEXT:    [[TMP1:%.*]] = load <2 x i32>, ptr addrspace(1) [[A_PTR]], align 4
; CHECK-NEXT:    [[A_VAL1:%.*]] = extractelement <2 x i32> [[TMP1]], i32 0
; CHECK-NEXT:    [[B_VAL2:%.*]] = extractelement <2 x i32> [[TMP1]], i32 1
; CHECK-NEXT:    ret void
;
  %a.offset = add nuw i32 %base, 4
  %t.offset.zexted = zext i32 %base to i64
  %a.offset.zexted = zext i32 %a.offset to i64
  %t.ptr = getelementptr inbounds i16, ptr addrspace(1) %p, i64 %t.offset.zexted
  %a.ptr = getelementptr inbounds i16, ptr addrspace(1) %p, i64 %a.offset.zexted
  %b.ptr = getelementptr inbounds i16, ptr addrspace(1) %t.ptr, i64 6
  %a.val = load i32, ptr addrspace(1) %a.ptr
  %b.val = load i32, ptr addrspace(1) %b.ptr
  ret void
}

; Check i1 corner case
define void @zexted_i1_gep_index(ptr addrspace(1) %p, i32 %val) {
; CHECK-LABEL: define void @zexted_i1_gep_index(
; CHECK-SAME: ptr addrspace(1) [[P:%.*]], i32 [[VAL:%.*]]) {
; CHECK-NEXT:    [[SELECTOR:%.*]] = icmp eq i32 [[VAL]], 0
; CHECK-NEXT:    [[FLIPPED:%.*]] = xor i1 [[SELECTOR]], true
; CHECK-NEXT:    [[INDEX_0:%.*]] = zext i1 [[SELECTOR]] to i64
; CHECK-NEXT:    [[INDEX_1:%.*]] = zext i1 [[FLIPPED]] to i64
; CHECK-NEXT:    [[GEP_0:%.*]] = getelementptr inbounds i32, ptr addrspace(1) [[P]], i64 [[INDEX_0]]
; CHECK-NEXT:    [[GEP_1:%.*]] = getelementptr inbounds i32, ptr addrspace(1) [[P]], i64 [[INDEX_1]]
; CHECK-NEXT:    [[VAL0:%.*]] = load i32, ptr addrspace(1) [[GEP_0]], align 4
; CHECK-NEXT:    [[VAL1:%.*]] = load i32, ptr addrspace(1) [[GEP_1]], align 4
; CHECK-NEXT:    ret void
;
  %selector = icmp eq i32 %val, 0
  %flipped = xor i1 %selector, 1
  %index.0 = zext i1 %selector to i64
  %index.1 = zext i1 %flipped to i64
  %gep.0 = getelementptr inbounds i32, ptr addrspace(1) %p, i64 %index.0
  %gep.1 = getelementptr inbounds i32, ptr addrspace(1) %p, i64 %index.1
  %val0 = load i32, ptr addrspace(1) %gep.0
  %val1 = load i32, ptr addrspace(1) %gep.1
  ret void
}

; Check i1 corner case
define void @sexted_i1_gep_index(ptr addrspace(1) %p, i32 %val) {
; CHECK-LABEL: define void @sexted_i1_gep_index(
; CHECK-SAME: ptr addrspace(1) [[P:%.*]], i32 [[VAL:%.*]]) {
; CHECK-NEXT:    [[SELECTOR:%.*]] = icmp eq i32 [[VAL]], 0
; CHECK-NEXT:    [[FLIPPED:%.*]] = xor i1 [[SELECTOR]], true
; CHECK-NEXT:    [[INDEX_0:%.*]] = sext i1 [[SELECTOR]] to i64
; CHECK-NEXT:    [[INDEX_1:%.*]] = sext i1 [[FLIPPED]] to i64
; CHECK-NEXT:    [[GEP_0:%.*]] = getelementptr inbounds i32, ptr addrspace(1) [[P]], i64 [[INDEX_0]]
; CHECK-NEXT:    [[GEP_1:%.*]] = getelementptr inbounds i32, ptr addrspace(1) [[P]], i64 [[INDEX_1]]
; CHECK-NEXT:    [[VAL0:%.*]] = load i32, ptr addrspace(1) [[GEP_0]], align 4
; CHECK-NEXT:    [[VAL1:%.*]] = load i32, ptr addrspace(1) [[GEP_1]], align 4
; CHECK-NEXT:    ret void
;
  %selector = icmp eq i32 %val, 0
  %flipped = xor i1 %selector, 1
  %index.0 = sext i1 %selector to i64
  %index.1 = sext i1 %flipped to i64
  %gep.0 = getelementptr inbounds i32, ptr addrspace(1) %p, i64 %index.0
  %gep.1 = getelementptr inbounds i32, ptr addrspace(1) %p, i64 %index.1
  %val0 = load i32, ptr addrspace(1) %gep.0
  %val1 = load i32, ptr addrspace(1) %gep.1
  ret void
}

define void @zexted_i1_gep_index_different_bbs(ptr addrspace(1) %p, i32 %val) {
; CHECK-LABEL: define void @zexted_i1_gep_index_different_bbs(
; CHECK-SAME: ptr addrspace(1) [[P:%.*]], i32 [[VAL:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[SELECTOR:%.*]] = icmp eq i32 [[VAL]], 0
; CHECK-NEXT:    [[FLIPPED:%.*]] = xor i1 [[SELECTOR]], true
; CHECK-NEXT:    [[INDEX_0:%.*]] = zext i1 [[SELECTOR]] to i64
; CHECK-NEXT:    [[INDEX_1:%.*]] = zext i1 [[FLIPPED]] to i64
; CHECK-NEXT:    [[GEP_0:%.*]] = getelementptr inbounds i32, ptr addrspace(1) [[P]], i64 [[INDEX_0]]
; CHECK-NEXT:    br label %[[NEXT:.*]]
; CHECK:       [[NEXT]]:
; CHECK-NEXT:    [[GEP_1:%.*]] = getelementptr inbounds i32, ptr addrspace(1) [[P]], i64 [[INDEX_1]]
; CHECK-NEXT:    [[VAL0:%.*]] = load i32, ptr addrspace(1) [[GEP_0]], align 4
; CHECK-NEXT:    [[VAL1:%.*]] = load i32, ptr addrspace(1) [[GEP_1]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %selector = icmp eq i32 %val, 0
  %flipped = xor i1 %selector, 1
  %index.0 = zext i1 %selector to i64
  %index.1 = zext i1 %flipped to i64
  %gep.0 = getelementptr inbounds i32, ptr addrspace(1) %p, i64 %index.0
  br label %next

next:
  %gep.1 = getelementptr inbounds i32, ptr addrspace(1) %p, i64 %index.1
  %val0 = load i32, ptr addrspace(1) %gep.0
  %val1 = load i32, ptr addrspace(1) %gep.1
  ret void
}
